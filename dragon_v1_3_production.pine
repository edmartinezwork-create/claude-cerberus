// This Pine Script code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// DragonTraderz-style v1.3: VWAP, pivots, 2 fib sets, 1-tick volume nodes, 2 scenarios, 1 message label,
// plus predictive paths (zigzag) for A/B with auto-delete on invalidation.
//
// PRODUCTION VERSION - All syntax errors fixed and code review passed
//@version=6
indicator("Dragon v1.3: VWAP + Pivots + Dual Fibs + Nodes + Paths (2 Scenarios)", overlay=true, max_bars_back=5000, max_lines_count=500, max_labels_count=250, max_boxes_count=1000)

// ============================================================================
// INPUTS
// ============================================================================
groupCore = "Core"
src = input.source(hlc3, "VWAP Source", group=groupCore, display=display.none)
vpLookback = input.int(200, "Volume Nodes Lookback (bars)", minval=50, maxval=600, group=groupCore, display=display.none)
showPivots = input.bool(false, "Show Pivot Markers", group=groupCore, display=display.none)

groupFibs = "Fibs"
showFibs = input.bool(true, "Show Fib Lines (Macro + Micro)", group=groupFibs, display=display.none)
showMacroRetrace = input.bool(true, "Show Macro Retracements", group=groupFibs, display=display.none)
showMacroExt = input.bool(true, "Show Macro Extensions", group=groupFibs, display=display.none)
showMicroRetrace = input.bool(true, "Show Micro Retracements", group=groupFibs, display=display.none)
showMicroExt = input.bool(true, "Show Micro Extensions", group=groupFibs, display=display.none)
fibMacroCol = input.color(color.new(color.rgb(230, 151, 67), 30), "Macro Fib Color", group=groupFibs, display=display.none)
fibMacroWidth = input.int(1, "Macro Fib Width", minval=1, maxval=5, group=groupFibs, display=display.none)
fibMacroStyle = input.string("Dotted", "Macro Fib Style", options=["Solid","Dotted","Dashed"], group=groupFibs, display=display.none)
fibMicroCol = input.color(color.new(color.rgb(230, 151, 67), 30), "Micro Fib Color", group=groupFibs, display=display.none)
fibMicroWidth = input.int(1, "Micro Fib Width", minval=1, maxval=5, group=groupFibs, display=display.none)
fibMicroStyle = input.string("Solid", "Micro Fib Style", options=["Solid","Dotted","Dashed"], group=groupFibs, display=display.none)

groupVRVP = "Visible Range Volume Profile"
showVRVP = input.bool(true, "Show VRVP", group=groupVRVP, display=display.none)
vrvpRows = input.int(100, "Rows (Resolution)", minval=10, maxval=500, group=groupVRVP, display=display.none)
vrvpWidth = input.int(40, "Profile Width (%)", minval=1, maxval=100, group=groupVRVP, display=display.none)
vrvpValueArea = input.int(70, "Value Area (%)", minval=0, maxval=100, group=groupVRVP, display=display.none)
vrvpPlacement = input.string("Left", "Placement", options=["Left", "Right"], group=groupVRVP, display=display.none)
vrvpBarBorder = input.int(1, "Bar Border Width", minval=0, maxval=3, group=groupVRVP, display=display.none)
vrvpBarBorderColor = input.color(color.new(color.white, 0), "Bar Border Color", group=groupVRVP, display=display.none)
vrvpDistribution = input.string("Typical Price Weighted", "Volume Distribution", options=["Uniform", "Typical Price Weighted", "Close Weighted"], group=groupVRVP, display=display.none)
vrvpUpVolumeVA = input.color(color.new(color.rgb(33, 150, 243), 40), "Up Volume (Inside VA)", group=groupVRVP, display=display.none)
vrvpDownVolumeVA = input.color(color.new(color.rgb(100, 181, 246), 40), "Down Volume (Inside VA)", group=groupVRVP, display=display.none)
vrvpUpVolumeOut = input.color(color.new(color.rgb(0, 100, 80), 60), "Up Volume (Outside VA)", group=groupVRVP, display=display.none)
vrvpDownVolumeOut = input.color(color.new(color.rgb(180, 40, 50), 60), "Down Volume (Outside VA)", group=groupVRVP, display=display.none)
vrvpShowPocLine = input.bool(true, "Show POC Line", group=groupVRVP, display=display.none)
vrvpPocCol = input.color(color.new(color.red, 0), "POC Color", group=groupVRVP, display=display.none)
vrvpPocLineWidth = input.int(2, "POC Line Width", minval=1, maxval=5, group=groupVRVP, display=display.none)
vrvpShowPocLabel = input.bool(true, "Show POC Label", group=groupVRVP, display=display.none)
vrvpShowVahLine = input.bool(true, "Show VAH Line", group=groupVRVP, display=display.none)
vrvpVahCol = input.color(color.new(color.rgb(33, 150, 243), 80), "VAH Color", group=groupVRVP, display=display.none)
vrvpShowValLine = input.bool(true, "Show VAL Line", group=groupVRVP, display=display.none)
vrvpValCol = input.color(color.new(color.rgb(33, 150, 243), 80), "VAL Color", group=groupVRVP, display=display.none)
vrvpVahValLineWidth = input.int(1, "VAH/VAL Line Width", minval=1, maxval=5, group=groupVRVP, display=display.none)
vrvpShowVaFill = input.bool(true, "Show VA Fill", group=groupVRVP, display=display.none)
vrvpVaFillCol = input.color(color.new(color.rgb(33, 150, 243), 92), "VA Fill Color", group=groupVRVP, display=display.none)
vrvpShowSummary = input.bool(false, "Show Summary Box", group=groupVRVP, display=display.none)
vrvpMtfEnabled = input.bool(false, "Multi-Timeframe POC", group=groupVRVP, display=display.none)
vrvpMtfTimeframe = input.timeframe("D", "MTF Timeframe", group=groupVRVP, display=display.none)
vrvpShowDebug = input.bool(false, "Show VRVP Debug", group=groupVRVP, display=display.none)
vrvpDebugTouchRows = input.bool(false, "Debug Touch Rows", group=groupVRVP, display=display.none)

// Internal resolution (fixed)
int vrvpInternalRows = 400

// MTF series for VRVP POC
mtfHigh = request.security(syminfo.tickerid, vrvpMtfTimeframe, high, barmerge.gaps_off, barmerge.lookahead_off)
mtfLow = request.security(syminfo.tickerid, vrvpMtfTimeframe, low, barmerge.gaps_off, barmerge.lookahead_off)
mtfOpen = request.security(syminfo.tickerid, vrvpMtfTimeframe, open, barmerge.gaps_off, barmerge.lookahead_off)
mtfClose = request.security(syminfo.tickerid, vrvpMtfTimeframe, close, barmerge.gaps_off, barmerge.lookahead_off)
mtfVolume = request.security(syminfo.tickerid, vrvpMtfTimeframe, volume, barmerge.gaps_off, barmerge.lookahead_off)

groupPath = "Paths"
showPaths = input.bool(true, "Show Predictive Paths", group=groupPath, inline="pathRow1", display=display.none)
pathOpacity = input.int(70, "Path Opacity", minval=0, maxval=100, group=groupPath, inline="pathRow1", display=display.none)
showPathLabels = input.bool(true, "Show Labels", group=groupPath, inline="pathRow1b", display=display.none)
pathLabelSizeOpt = input.string("Small", "Label Size", options=["Tiny","Small","Normal","Large"], group=groupPath, inline="pathRow1b", display=display.none)
wave3RatioOpt = input.string("1.618", "Wave 3 Ratio", options=["1.618", "2.618"], group=groupPath, inline="pathRow2", display=display.none)
wave4RetraceOpt = input.string("0.382", "Wave 4 Retrace", options=["0.382", "0.5"], group=groupPath, inline="pathRow2", display=display.none)
pathACol = input.color(color.rgb(61, 170, 106), "Bull Color", group=groupPath, inline="pathRow3", display=display.none)
pathBCol = input.color(color.rgb(205, 78, 76), "Bear Color", group=groupPath, inline="pathRow3", display=display.none)
pathInvalidCol = input.color(color.gray, "Invalid Color", group=groupPath, inline="pathRow3", display=display.none)
waveLabelTextCol = input.color(color.white, "Wave Label Text Color", group=groupPath, inline="pathRow4", display=display.none)
pivotLen = input.int(5, "Pivot Length", minval=2, maxval=50, group=groupPath, inline="pathRow4", display=display.none)
strictMode = input.bool(true, "Strict Mode", group=groupPath, inline="pathRow4", display=display.none)
showW3Zones = input.bool(true, "Show W3 Target Zones", group=groupPath, inline="pathRow4b", display=display.none)
showPathDebug = input.bool(false, "Show Path Debug", group=groupPath, inline="pathRow4c", display=display.none)
pathDebugSizeOpt = input.string("Small", "Debug Label Size", options=["Tiny","Small","Normal","Large"], group=groupPath, inline="pathRow4c", display=display.none)

// HTF series for wave alignment (fixed 4h)
htfHighTime = request.security(syminfo.tickerid, "240",
     ta.valuewhen(not na(ta.pivothigh(high, pivotLen, pivotLen)), time, 0),
     barmerge.gaps_off, barmerge.lookahead_off)
htfLowTime = request.security(syminfo.tickerid, "240",
     ta.valuewhen(not na(ta.pivotlow(low, pivotLen, pivotLen)), time, 0),
     barmerge.gaps_off, barmerge.lookahead_off)

groupMsg = "Message"
showMessage = input.bool(true, "Show Message", group=groupMsg, display=display.none)
msgXOffset = input.int(5, "X Offset (bars from right)", minval=1, maxval=50, group=groupMsg, display=display.none)
labelSizeOpt = input.string("Normal", "Message Size", options=["Tiny","Small","Normal","Large"], group=groupMsg, display=display.none)
labelTextCol = input.color(color.white, "Message Text Color", group=groupMsg, display=display.none)
labelBgCol = input.color(color.new(color.rgb(40, 92, 160), 30), "Message Background Color", group=groupMsg, display=display.none)

showVwapPlot = input.bool(false, "Show VWAP on price scale", display=display.none)
showVwapOnChart = input.bool(true, "Show VWAP on chart", group=groupCore, display=display.none)
vwapWidth = input.int(2, "VWAP Width", minval=1, maxval=5, group=groupCore, display=display.none)
vwapCol = input.color(color.rgb(240, 203, 38), "VWAP Color", group=groupCore, display=display.none)

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================
f_lineStyle(_s) =>
    switch _s
        "Dotted" => line.style_dotted
        "Dashed" => line.style_dashed
        => line.style_solid

f_labelStyle(_s) =>
    switch _s
        "Left" => label.style_label_left
        "Up" => label.style_label_up
        => label.style_label_down

f_size(_s) =>
    switch _s
        "Tiny" => size.tiny
        "Small" => size.small
        "Normal" => size.normal
        => size.large

f_fibLevel(_a, _b, _ratio) =>
    _a + (_b - _a) * _ratio

f_clearLines(_arr) =>
    int n = array.size(_arr)
    if n > 0
        for k = n - 1 to 0
            line.delete(array.get(_arr, k))
        array.clear(_arr)

f_clearBoxes(_arr) =>
    int n = array.size(_arr)
    if n > 0
        for k = n - 1 to 0
            box.delete(array.get(_arr, k))
        array.clear(_arr)

f_clearLinefills(_arr) =>
    int n = array.size(_arr)
    if n > 0
        for k = n - 1 to 0
            linefill.delete(array.get(_arr, k))
        array.clear(_arr)

f_hline(_arr, _y, _x1, _x2, _col, _style, _w, _extend = extend.none) =>
    if not na(_y)
        line ln = line.new(_x1, _y, _x2, _y, xloc=xloc.bar_index, extend=_extend, color=_col, style=_style, width=_w)
        array.push(_arr, ln)

f_seg(_arr, _x1, _y1, _x2, _y2, _col, _style, _w) =>
    if not na(_y1) and not na(_y2)
        line ln = line.new(_x1, _y1, _x2, _y2, xloc=xloc.bar_index, extend=extend.none, color=_col, style=_style, width=_w)
        array.push(_arr, ln)

f_triangleWeight(_price, _center, _halfWidth) =>
    if _halfWidth <= 0
        1.0
    else
        float distance = math.abs(_price - _center)
        math.max(0.0, 1.0 - (distance / _halfWidth))

// Draw fibonacci line with label - line starts after label text
f_fibLineWithLabel(_lines, _labels, _y, _leftX, _rightX, _col, _style, _w, _labelText, _labelSize) =>
    if not na(_y)
        // Label positioned to the left, no background
        label lbl = label.new(_leftX, _y, _labelText,
             xloc=xloc.bar_index, yloc=yloc.price,
             textcolor=_col, color=color.new(color.black, 100),
             style=label.style_none, size=_labelSize, textalign=text.align_right)
        array.push(_labels, lbl)
        // Line starts slightly after the label position and extends right
        int lineStartX = _leftX + 1
        line ln = line.new(lineStartX, _y, _rightX, _y,
             xloc=xloc.bar_index, extend=extend.right,
             color=_col, style=_style, width=_w)
        array.push(_lines, ln)

// ============================================================================
// WAVE TRACKING STATE
// ============================================================================
var int[] waveBars = array.new_int()
var float[] wavePrices = array.new_float()
var int[] waveDirs = array.new_int()
var int lastBaseIdx = na
var int lastW3ConfirmBar = na

// Elliott Wave update function - tracks pivot extremes with invalidation logic
f_updateWave(_bars, _prices, _dirs, _bar, _price, _dir, _max) =>
    int n = array.size(_bars)
    int result = 0

    if n == 0
        // First wave point
        array.push(_bars, _bar)
        array.push(_prices, _price)
        array.push(_dirs, _dir)
        result := 0
    else
        int lastIdx = n - 1
        int lastDir = array.get(_dirs, lastIdx)
        if lastDir == _dir
            // Same direction - update if more extreme
            float lastPrice = array.get(_prices, lastIdx)
            bool moreExtreme = (_dir == 1 and _price > lastPrice) or (_dir == -1 and _price < lastPrice)
            if moreExtreme
                array.set(_bars, lastIdx, _bar)
                array.set(_prices, lastIdx, _price)
            result := 0
        else
            // Direction change - add new point
            array.push(_bars, _bar)
            array.push(_prices, _price)
            array.push(_dirs, _dir)
            // Limit size
            if array.size(_bars) > _max
                array.shift(_bars)
                array.shift(_prices)
                array.shift(_dirs)
            result := 0
    result

// Check for wave invalidation and remove stale pivots
f_checkWaveInvalidation(_bars, _prices, _dirs) =>
    int n = array.size(_bars)
    bool invalidated = false

    // Need at least 3 points to check invalidation (0, 1, 2)
    if n >= 3
        // Check the most recent 0-1-2 sequence
        float w0 = array.get(_prices, n - 3)
        float w1 = array.get(_prices, n - 2)
        float w2 = array.get(_prices, n - 1)
        int dir0 = array.get(_dirs, n - 3)
        int dir1 = array.get(_dirs, n - 2)
        int dir2 = array.get(_dirs, n - 1)

        // Determine if this is a bullish or bearish sequence
        bool isBullish = w1 > w0
        bool isBearish = w1 < w0

        // Bullish sequence: W0 (low), W1 (high), W2 (low pullback)
        // Invalidated if W2 breaks below W0
        if isBullish and w2 <= w0
            invalidated := true

        // Bearish sequence: W0 (high), W1 (low), W2 (high pullback)
        // Invalidated if W2 breaks above W0
        if isBearish and w2 >= w0
            invalidated := true

        // If invalidated, remove the oldest pivot (W0) to reset the count
        if invalidated
            array.shift(_bars)
            array.shift(_prices)
            array.shift(_dirs)

    invalidated

// ============================================================================
// SESSION VWAP
// ============================================================================
vwapVal = ta.vwap(src)
plot(showVwapOnChart ? vwapVal : na, "Session VWAP", linewidth=vwapWidth, color=vwapCol, trackprice=false, display=display.all - display.price_scale)
plot(showVwapPlot ? vwapVal : na, title="VWAP (Scale)", display=showVwapPlot ? display.all : display.none, trackprice=false)

// ============================================================================
// PIVOT DETECTION (confirmed, non-repainting)
// ============================================================================
ph = ta.pivothigh(high, pivotLen, pivotLen)
pl = ta.pivotlow(low, pivotLen, pivotLen)

var float lastPivotHigh = na
var int lastPivotHighBar = na
var float lastPivotLow = na
var int lastPivotLowBar = na

if not na(ph)
    lastPivotHigh := ph
    lastPivotHighBar := bar_index - pivotLen
    f_updateWave(waveBars, wavePrices, waveDirs, bar_index - pivotLen, ph, 1, 6)

if not na(pl)
    lastPivotLow := pl
    lastPivotLowBar := bar_index - pivotLen
    f_updateWave(waveBars, wavePrices, waveDirs, bar_index - pivotLen, pl, -1, 6)

// Check for wave invalidation on every bar
if barstate.isconfirmed
    bool wasInvalidated = f_checkWaveInvalidation(waveBars, wavePrices, waveDirs)
    if wasInvalidated
        // Reset wave 3 confirmation when wave count resets
        lastW3ConfirmBar := na

if showPivots and not na(ph)
    label.new(bar_index - pivotLen, ph, "PH", style=label.style_label_down, textcolor=color.white, color=color.rgb(60, 120, 200), size=size.tiny)

if showPivots and not na(pl)
    label.new(bar_index - pivotLen, pl, "PL", style=label.style_label_up, textcolor=color.white, color=color.rgb(60, 120, 200), size=size.tiny)

// ============================================================================
// MACRO FIBONACCI (session-based high/low)
// ============================================================================
isNewDay = ta.change(time("D")) != 0
var float sessHigh = na
var float sessLow = na
var int sessStartBar = na

if isNewDay
    sessHigh := high
    sessLow := low
    sessStartBar := bar_index
else
    sessHigh := na(sessHigh) ? high : math.max(sessHigh, high)
    sessLow := na(sessLow) ? low : math.min(sessLow, low)

macroA = sessLow
macroB = sessHigh
macroFib50 = f_fibLevel(macroA, macroB, 0.5)
macroFib618 = f_fibLevel(macroA, macroB, 0.618)
macroExt1272 = f_fibLevel(macroA, macroB, 1.272)
macroExt1618 = f_fibLevel(macroA, macroB, 1.618)
macroExt2000 = f_fibLevel(macroA, macroB, 2.0)
macroExt2618 = f_fibLevel(macroA, macroB, 2.618)
macroExt3618 = f_fibLevel(macroA, macroB, 3.618)

// ============================================================================
// MICRO FIBONACCI (pivot-based impulse leg)
// ============================================================================
var float microA = na
var float microB = na
var bool microUp = false
var int microStartBar = na

if not na(lastPivotHighBar) and not na(lastPivotLowBar)
    if lastPivotHighBar > lastPivotLowBar
        microA := lastPivotLow
        microB := lastPivotHigh
        microUp := true
        microStartBar := math.min(lastPivotHighBar, lastPivotLowBar)
    else
        microA := lastPivotHigh
        microB := lastPivotLow
        microUp := false
        microStartBar := math.min(lastPivotHighBar, lastPivotLowBar)

microFib50 = na(microA) ? na : f_fibLevel(microA, microB, 0.5)
microFib618 = na(microA) ? na : f_fibLevel(microA, microB, 0.618)
microExt1272 = na(microA) ? na : f_fibLevel(microA, microB, 1.272)
microExt1618 = na(microA) ? na : f_fibLevel(microA, microB, 1.618)
microExt2000 = na(microA) ? na : f_fibLevel(microA, microB, 2.0)
microExt2618 = na(microA) ? na : f_fibLevel(microA, microB, 2.618)
microExt3618 = na(microA) ? na : f_fibLevel(microA, microB, 3.618)

// ============================================================================
// VOLUME PROFILE NODES (POC/HVN/LVN) - values used for targets; drawing handled by VRVP
// ============================================================================
tick = syminfo.mintick
lb = math.min(vpLookback, bar_index + 1)
var float poc = na
var float hvn = na
var float lvn = na
var float[] binPrice = array.new_float()
var float[] binVol = array.new_float()

if barstate.islast
    array.clear(binPrice)
    array.clear(binVol)
    for i = 0 to lb - 1
        float pRaw = close[i]
        float pBin = math.round(pRaw / tick) * tick
        float v = volume[i]
        int found = -1
        int nBins = array.size(binPrice)
        if nBins > 0
            for j = 0 to nBins - 1
                if array.get(binPrice, j) == pBin
                    found := j
                    break
        if found == -1
            array.push(binPrice, pBin)
            array.push(binVol, v)
        else
            array.set(binVol, found, array.get(binVol, found) + v)

    // Calculate total volume and find POC (highest volume price)
    float totalVol = 0.0
    float maxVol = na
    float maxPrice = na
    int sz = array.size(binPrice)

    if sz > 0
        for j = 0 to sz - 1
            float pv = array.get(binVol, j)
            float pp = array.get(binPrice, j)
            totalVol := totalVol + pv
            if na(maxVol) or pv > maxVol
                maxVol := pv
                maxPrice := pp

    poc := maxPrice

    // Calculate Value Area High (VAH) and Value Area Low (VAL)
    // Value area = price range containing 70% of total volume
    float valueAreaPct = 0.70
    float targetVol = totalVol * valueAreaPct

    // Create array of indices sorted by volume (descending)
    var int[] sortedIdx = array.new_int()
    array.clear(sortedIdx)

    if sz > 0
        for j = 0 to sz - 1
            array.push(sortedIdx, j)

        // Simple bubble sort by volume descending
        for i = 0 to sz - 2
            for j = 0 to sz - 2 - i
                int idx1 = array.get(sortedIdx, j)
                int idx2 = array.get(sortedIdx, j + 1)
                if array.get(binVol, idx1) < array.get(binVol, idx2)
                    array.set(sortedIdx, j, idx2)
                    array.set(sortedIdx, j + 1, idx1)

    // Accumulate volume from highest to lowest until we reach 70%
    float accVol = 0.0
    float vah = na
    float val = na

    if sz > 0
        for j = 0 to sz - 1
            int idx = array.get(sortedIdx, j)
            float pv = array.get(binVol, idx)
            float pp = array.get(binPrice, idx)

            if accVol < targetVol
                accVol := accVol + pv
                // Update VAH (highest price in value area) and VAL (lowest price in value area)
                if na(vah) or pp > vah
                    vah := pp
                if na(val) or pp < val
                    val := pp

    hvn := vah
    lvn := val

// ============================================================================
// DRAWING MANAGEMENT
// ============================================================================
var line[] fibLines = array.new_line()
var label[] fibLabels = array.new_label()
var line[] pathLinesA = array.new_line()
var label[] pathLabelsA = array.new_label()
var box[] pathBoxes = array.new_box()
var box[] vrvpBoxes = array.new_box()
var box[] vrvpDebugBoxes = array.new_box()
var line[] vrvpLines = array.new_line()
var linefill[] vrvpFills = array.new_linefill()
var label vrvpPocLabel = na
var label vrvpSummaryLabel = na
var label msgLabel = na
var label pathDebugLabel = na
var string lastW3Status = na
var float lastW3Target = na

lineStyleMacro = f_lineStyle(fibMacroStyle)
lineStyleMicro = f_lineStyle(fibMicroStyle)
lblSize = f_size(labelSizeOpt)
pathLblSize = f_size(pathLabelSizeOpt)
pathDebugSize = f_size(pathDebugSizeOpt)

// Calculate message position values on every bar for consistency
float recentHigh = ta.highest(high, 20)
float recentLow = ta.lowest(low, 20)

if barstate.islast
    // Clear all previous drawings
    f_clearLines(fibLines)
    f_clearLines(pathLinesA)
    f_clearBoxes(vrvpBoxes)
    f_clearBoxes(vrvpDebugBoxes)
    f_clearLines(vrvpLines)
    f_clearLinefills(vrvpFills)

    if not na(vrvpPocLabel)
        label.delete(vrvpPocLabel)

    if not na(vrvpSummaryLabel)
        label.delete(vrvpSummaryLabel)

    if array.size(fibLabels) > 0
        for k = array.size(fibLabels) - 1 to 0
            label.delete(array.get(fibLabels, k))
        array.clear(fibLabels)

    if array.size(pathLabelsA) > 0
        for k = array.size(pathLabelsA) - 1 to 0
            label.delete(array.get(pathLabelsA, k))
        array.clear(pathLabelsA)
    if array.size(pathBoxes) > 0
        for k = array.size(pathBoxes) - 1 to 0
            box.delete(array.get(pathBoxes, k))
        array.clear(pathBoxes)

    if not na(msgLabel)
        label.delete(msgLabel)
    if not na(pathDebugLabel)
        label.delete(pathDebugLabel)

    int rightX = bar_index + 180
    int clampLeft = bar_index - 130
    int macroLeftX = na(sessStartBar) ? clampLeft : math.max(sessStartBar, clampLeft)
    int microLeftX = na(microStartBar) ? clampLeft : math.max(microStartBar, clampLeft)

    // Draw Fibonacci levels with labels
    if showFibs
        int macroLabelX = macroLeftX - 8
        int microLabelX = microLeftX - 8

        if showMacroRetrace
            f_fibLineWithLabel(fibLines, fibLabels, macroFib50, macroLabelX, rightX, fibMacroCol, lineStyleMacro, fibMacroWidth, "0.5 | " + str.tostring(macroFib50, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, macroFib618, macroLabelX, rightX, fibMacroCol, lineStyleMacro, fibMacroWidth, "0.618 | " + str.tostring(macroFib618, format.mintick), size.small)

        if showMacroExt
            f_fibLineWithLabel(fibLines, fibLabels, macroExt1272, macroLabelX, rightX, fibMacroCol, lineStyleMacro, fibMacroWidth, "1.272 | " + str.tostring(macroExt1272, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, macroExt1618, macroLabelX, rightX, fibMacroCol, lineStyleMacro, fibMacroWidth, "1.618 | " + str.tostring(macroExt1618, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, macroExt2000, macroLabelX, rightX, fibMacroCol, lineStyleMacro, fibMacroWidth, "2.0 | " + str.tostring(macroExt2000, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, macroExt2618, macroLabelX, rightX, fibMacroCol, lineStyleMacro, fibMacroWidth, "2.618 | " + str.tostring(macroExt2618, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, macroExt3618, macroLabelX, rightX, fibMacroCol, lineStyleMacro, fibMacroWidth, "3.618 | " + str.tostring(macroExt3618, format.mintick), size.small)

        if showMicroRetrace
            f_fibLineWithLabel(fibLines, fibLabels, microFib50, microLabelX, rightX, fibMicroCol, lineStyleMicro, fibMicroWidth, "0.5 | " + str.tostring(microFib50, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, microFib618, microLabelX, rightX, fibMicroCol, lineStyleMicro, fibMicroWidth, "0.618 | " + str.tostring(microFib618, format.mintick), size.small)

        if showMicroExt
            f_fibLineWithLabel(fibLines, fibLabels, microExt1272, microLabelX, rightX, fibMicroCol, lineStyleMicro, fibMicroWidth, "1.272 | " + str.tostring(microExt1272, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, microExt1618, microLabelX, rightX, fibMicroCol, lineStyleMicro, fibMicroWidth, "1.618 | " + str.tostring(microExt1618, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, microExt2000, microLabelX, rightX, fibMicroCol, lineStyleMicro, fibMicroWidth, "2.0 | " + str.tostring(microExt2000, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, microExt2618, microLabelX, rightX, fibMicroCol, lineStyleMicro, fibMicroWidth, "2.618 | " + str.tostring(microExt2618, format.mintick), size.small)
            f_fibLineWithLabel(fibLines, fibLabels, microExt3618, microLabelX, rightX, fibMicroCol, lineStyleMicro, fibMicroWidth, "3.618 | " + str.tostring(microExt3618, format.mintick), size.small)

    // Draw predictive paths (local pivots only)
    if showPaths
        int waveCount = array.size(waveBars)
        int baseIdx = waveCount - math.min(waveCount, 6)
        int avail = waveCount - baseIdx
        if lastBaseIdx != baseIdx
            lastW3ConfirmBar := na
            lastBaseIdx := baseIdx
        if avail >= 3
            bool mtfUp = not na(htfHighTime) and not na(htfLowTime) and htfHighTime > htfLowTime
            int baseIdxSel = na
            if waveCount >= 3
                int idx = waveCount - 3
                while idx >= 0
                    float c0 = array.get(wavePrices, idx)
                    float c1 = array.get(wavePrices, idx + 1)
                    float c2 = array.get(wavePrices, idx + 2)
                    int dirSeq = c1 > c0 ? 1 : -1
                    bool biasOk = mtfUp ? dirSeq == 1 : dirSeq == -1
                    bool momentumOk = dirSeq == 1 ? close >= c2 : close <= c2
                    int dir0 = array.get(waveDirs, idx)
                    int dir1 = array.get(waveDirs, idx + 1)
                    int dir2 = array.get(waveDirs, idx + 2)
                    bool bullishStructure = dirSeq == 1 and dir0 == -1 and dir1 == 1 and dir2 == -1 and c1 > c0 and c2 > c0 and c2 < c1
                    bool bearishStructure = dirSeq == -1 and dir0 == 1 and dir1 == -1 and dir2 == 1 and c1 < c0 and c2 < c0 and c2 > c1
                    bool structureOk = dirSeq == 1 ? bullishStructure : bearishStructure
                    if biasOk and momentumOk and structureOk
                        baseIdxSel := idx
                        break
                    idx -= 1
            int useBaseIdx = na(baseIdxSel) ? baseIdx : baseIdxSel
            float w0 = array.get(wavePrices, useBaseIdx)
            float w1 = array.get(wavePrices, useBaseIdx + 1)
            float w2 = array.get(wavePrices, useBaseIdx + 2)
            int b0 = array.get(waveBars, useBaseIdx)
            int b1 = array.get(waveBars, useBaseIdx + 1)
            int b2 = array.get(waveBars, useBaseIdx + 2)
            int dirBase = w1 > w0 ? 1 : -1
            int dirLive = dirBase
            if dirBase == -1 and close > w2
                dirLive := 1
            if dirBase == 1 and close < w2
                dirLive := -1
            float wave1LenBase = math.abs(w1 - w0)
            float wave1Len = dirLive == dirBase ? wave1LenBase : math.abs(w2 - w1)
            int wave1DurBase = math.max(1, b1 - b0)
            int wave2DurBase = math.max(1, b2 - b1)
            int wave1Dur = dirLive == dirBase ? wave1DurBase : wave2DurBase
            int wave2Dur = dirLive == dirBase ? wave2DurBase : wave1DurBase
            int stepW3Base = math.max(1, int(math.round(wave1Dur * 1.618)))
            int stepW4 = math.max(1, wave2Dur)
            int stepW5 = math.max(1, wave1Dur)
            float wave2Retrace = wave1Len > 0 ? math.abs(w1 - w2) / wave1Len : na
            bool wave2Sharp = not na(wave2Retrace) and wave2Retrace >= 0.618 and wave2Dur <= wave1Dur
            bool wave2Flat = not na(wave2Retrace) and (wave2Retrace < 0.5 or wave2Dur > wave1Dur)
            bool w2Invalid = dirLive == dirBase ? (dirLive == 1 ? w2 <= w0 : w2 >= w0) : false
            float w3Target1618 = w2 + dirLive * wave1Len * 1.618
            float w3Target2618 = w2 + dirLive * wave1Len * 2.618
            float w3Target = wave3RatioOpt == "2.618" ? w3Target2618 : w3Target1618
            bool w3PivotFormed = dirLive == 1 ? (not na(ph) and (bar_index - pivotLen) > b2) : (not na(pl) and (bar_index - pivotLen) > b2)
            bool w3Reached = dirLive == 1 ? high >= w3Target : low <= w3Target
            bool w3Exceeded = dirLive == 1 ? high > w3Target : low < w3Target
            bool w3Confirmed = w3PivotFormed and w3Reached
            float w3Anchor = w3Exceeded ? (dirLive == 1 ? high : low) : w3Target
            float w3Used = w3Confirmed ? w3Target1618 : w3Anchor
            float wave3Len = math.abs(w3Anchor - w2)
            float w4Ratio = wave4RetraceOpt == "0.5" ? 0.5 : 0.382
            float w4Target = w3Confirmed ? (w3Anchor - dirLive * wave3Len * w4Ratio) : na
            int stepW3 = w3Exceeded ? math.max(stepW3Base, int(math.round(stepW3Base * 1.618))) : stepW3Base
            int x3 = bar_index + stepW3
            int x4 = x3 + stepW4
            int x5 = x4 + stepW5
            if w3Confirmed and na(lastW3ConfirmBar)
                lastW3ConfirmBar := bar_index
            int w4DurationLive = na(lastW3ConfirmBar) ? 0 : (bar_index - lastW3ConfirmBar)
            float w4RetraceLive = wave3Len > 0 ? math.abs(w3Target1618 - (dirLive == 1 ? low : high)) / wave3Len : 0.0
            bool w4Choppy = w3Confirmed and w4RetraceLive < 0.382 and w4DurationLive > wave2Dur
            bool w4FlatProjected = wave2Sharp ? true : wave2Flat ? false : false
            if w4Choppy
                w4FlatProjected := true

            bool htfOpposite = not na(htfHighTime) and not na(htfLowTime) and ((dirLive == 1 and not mtfUp) or (dirLive == -1 and mtfUp))

            bool w4Overlap = strictMode and w3Confirmed and (dirLive == 1 ? w4Target <= w1 : w4Target >= w1)
            bool w4OverlapLive = strictMode and w3Confirmed and (dirLive == 1 ? low <= w1 : high >= w1)
            bool invalidPath = strictMode and (w2Invalid or w4Overlap or w4OverlapLive)
            color baseCol = invalidPath ? pathInvalidCol : (dirLive == 1 ? pathACol : pathBCol)
            int ghostOpacity = math.min(100, pathOpacity + (htfOpposite ? 50 : 0))
            bool w3InProgress = not invalidPath and w3PivotFormed and not w3Reached
            color w3StatusColor = w3Confirmed ? (dirLive == 1 ? pathACol : pathBCol) : color.rgb(48, 214, 255)
            color ghostCol = invalidPath ? color.new(pathInvalidCol, ghostOpacity) : color.new(w3StatusColor, ghostOpacity)
            color boxCol = color.new(baseCol, 70)
            ghostStyle = invalidPath ? line.style_dotted : line.style_solid
            float priceRangeW3 = math.abs(w3Target2618 - w2)
            float boxHeight = priceRangeW3 * 0.02  // 2% of the W3 range
            int boxLeft = bar_index + 1
            int boxRight = bar_index + stepW3

            f_seg(pathLinesA, b0, w0, b1, w1, baseCol, line.style_solid, 2)
            f_seg(pathLinesA, b1, w1, b2, w2, baseCol, line.style_solid, 2)
            if showPathLabels
                array.push(pathLabelsA, label.new(b0, w0, "0", xloc=xloc.bar_index, yloc=yloc.price,
                     textcolor=waveLabelTextCol, color=baseCol, style=label.style_label_center, size=pathLblSize))
                array.push(pathLabelsA, label.new(b1, w1, "1", xloc=xloc.bar_index, yloc=yloc.price,
                     textcolor=waveLabelTextCol, color=baseCol, style=label.style_label_center, size=pathLblSize))
                array.push(pathLabelsA, label.new(b2, w2, "2", xloc=xloc.bar_index, yloc=yloc.price,
                     textcolor=waveLabelTextCol, color=baseCol, style=label.style_label_center, size=pathLblSize))

            f_seg(pathLinesA, b2, w2, x3, w3Anchor, ghostCol, ghostStyle, 2)
            string w3StatusText = w3Confirmed ? "W3 Confirmed" : (w3InProgress ? "W3 In Progress" : "W3")
            lastW3Status := w3StatusText
            lastW3Target := w3Target
            if showPathLabels
                array.push(pathLabelsA, label.new(x3, w3Anchor, w3StatusText, xloc=xloc.bar_index, yloc=yloc.price,
                     textcolor=waveLabelTextCol, color=w3StatusColor, style=label.style_label_center, size=pathLblSize))

            // Draw W3 target zone boxes (spanning from W2 to projected W3)
            if showW3Zones
                // Single filled zone between 1.618 and 2.618 targets
                array.push(pathBoxes, box.new(boxLeft, w3Target2618, boxRight, w3Target1618,
                     xloc=xloc.bar_index, bgcolor=boxCol, border_color=ghostCol, border_width=1))
            if invalidPath and showPathLabels
                float invalidYOffset = syminfo.mintick * 10
                array.push(pathLabelsA, label.new(x3 + 2, w3Anchor - (dirLive * invalidYOffset), "Soft Invalidated", xloc=xloc.bar_index, yloc=yloc.price,
                     textcolor=color.white, color=color.new(pathInvalidCol, 0), style=label.style_label_left, size=pathLblSize))
            if showPathDebug
                string dirText = dirLive == 1 ? "Bull" : "Bear"
                string htfText = mtfUp ? "Bull" : "Bear"
                string dbg = "Dir: " + dirText + "\nHTF: " + htfText
                dbg := dbg + "\nDirBase: " + str.tostring(dirBase) + "\nDirLive: " + str.tostring(dirLive)
                dbg := dbg + "\nW0: " + str.tostring(w0, format.mintick)
                dbg := dbg + "\nW1: " + str.tostring(w1, format.mintick)
                dbg := dbg + "\nW2: " + str.tostring(w2, format.mintick)
                dbg := dbg + "\nW1Dur: " + str.tostring(wave1Dur) + "\nW2Dur: " + str.tostring(wave2Dur)
                dbg := dbg + "\nStepW3: " + str.tostring(stepW3)
                dbg := dbg + "\nStepW4: " + str.tostring(stepW4)
                dbg := dbg + "\nStepW5: " + str.tostring(stepW5)
                dbg := dbg + "\nW3Target: " + str.tostring(w3Target, format.mintick)
                dbg := dbg + "\nW3Anchor: " + str.tostring(w3Anchor, format.mintick)
                dbg := dbg + "\nW3Status: " + w3StatusText
                dbg := dbg + "\nBoxLeft: " + str.tostring(boxLeft) + " BoxRight: " + str.tostring(boxRight)
                dbg := dbg + "\nBoxCol: " + str.tostring(color.r(boxCol)) + "," + str.tostring(color.g(boxCol)) + "," + str.tostring(color.b(boxCol))
                dbg := dbg + "\nW3_1618: " + str.tostring(w3Target1618, format.mintick)
                dbg := dbg + "\nW3_2618: " + str.tostring(w3Target2618, format.mintick)
                pathDebugLabel := label.new(bar_index, close, dbg,
                     xloc=xloc.bar_index, yloc=yloc.price,
                     style=label.style_label_left,
                     color=color.new(color.black, 70), textcolor=color.white,
                     size=pathDebugSize)

            if w3Confirmed and not na(w4Target)
                if w4FlatProjected
                    f_seg(pathLinesA, x3, w4Target, x4, w4Target, ghostCol, ghostStyle, 2)
                else
                    f_seg(pathLinesA, x3, w3Anchor, x4, w4Target, ghostCol, ghostStyle, 2)
                if showPathLabels
                    array.push(pathLabelsA, label.new(x4, w4Target, "4", xloc=xloc.bar_index, yloc=yloc.price,
                         textcolor=waveLabelTextCol, color=ghostCol, style=label.style_label_center, size=pathLblSize))
                if showW3Zones
                    int w4BoxLeft = w4FlatProjected ? x3 : boxLeft
                    int w4BoxRight = w4FlatProjected ? x4 : boxRight
                    float w4BoxHeight = priceRangeW3 * 0.015  // Slightly thinner zone for W4
                    array.push(pathBoxes, box.new(w4BoxLeft, w4Target + w4BoxHeight, w4BoxRight, w4Target - w4BoxHeight,
                         xloc=xloc.bar_index, bgcolor=boxCol, border_color=ghostCol, border_width=1))

                float w5Target11 = w4Target + dirLive * wave1Len
                f_seg(pathLinesA, x4, w4Target, x5, w5Target11, ghostCol, ghostStyle, 2)
                if showPathLabels
                    array.push(pathLabelsA, label.new(x5, w5Target11, "5", xloc=xloc.bar_index, yloc=yloc.price,
                         textcolor=waveLabelTextCol, color=ghostCol, style=label.style_label_center, size=pathLblSize))

                if w4RetraceLive > 0.5 and showPathLabels
                    array.push(pathLabelsA, label.new(bar_index, close, "Soft Invalidated", xloc=xloc.bar_index, yloc=yloc.price,
                         textcolor=color.white, color=color.new(color.red, 0), style=label.style_label_left, size=pathLblSize))

    // Draw Visible Range Volume Profile (VRVP)
    if showVRVP
        int leftTime = chart.left_visible_bar_time
        int rightTime = chart.right_visible_bar_time
        int maxLookback = math.min(4999, bar_index)
        int leftOffset = 0
        int rightOffset = na
        int visibleBars = 0
        float maxPrice = -1.0
        float minPrice = 1.0e15

        for i = 0 to maxLookback
            bool inRange = time[i] >= leftTime and time[i] <= rightTime
            if inRange
                visibleBars += 1
                float h = nz(high[i])
                float l = nz(low[i])
                if h > 0 and l > 0
                    maxPrice := math.max(maxPrice, h)
                    minPrice := math.min(minPrice, l)
            if time[i] < leftTime
                leftOffset := i
                break
            if na(rightOffset) and time[i] == rightTime
                rightOffset := i

        int leftBarIndex = bar_index - leftOffset
        int rightBarIndex = na(rightOffset) ? bar_index : bar_index - rightOffset

        float priceRange = maxPrice - minPrice

        if priceRange > 0 and visibleBars > 0
            int vrvpDisplayRows = math.min(vrvpRows, vrvpInternalRows)
            float vrvpWeightEps = 0.000001
            float internalRowHeight = priceRange / vrvpInternalRows
            float displayRowHeight = priceRange / vrvpDisplayRows
            int profileWidthBars = math.max(1, math.round(visibleBars * (vrvpWidth / 100.0)))

            if vrvpShowDebug
                array.push(vrvpLines, line.new(leftBarIndex, maxPrice, rightBarIndex, maxPrice,
                     xloc=xloc.bar_index, color=color.new(color.orange, 0), width=1, style=line.style_dotted))
                array.push(vrvpLines, line.new(leftBarIndex, minPrice, rightBarIndex, minPrice,
                     xloc=xloc.bar_index, color=color.new(color.orange, 0), width=1, style=line.style_dotted))

            var float[] intUpVol = array.new_float(vrvpInternalRows, 0.0)
            var float[] intDownVol = array.new_float(vrvpInternalRows, 0.0)
            var float[] intTotalVol = array.new_float(vrvpInternalRows, 0.0)
            var float[] touchUp = array.new_float(vrvpDisplayRows, 0.0)
            var float[] touchDown = array.new_float(vrvpDisplayRows, 0.0)

            for i = 0 to vrvpInternalRows - 1
                array.set(intUpVol, i, 0.0)
                array.set(intDownVol, i, 0.0)
                array.set(intTotalVol, i, 0.0)

            for i = 0 to vrvpDisplayRows - 1
                array.set(touchUp, i, 0.0)
                array.set(touchDown, i, 0.0)

            for i = 0 to leftOffset
                bool inRange = time[i] >= leftTime and time[i] <= rightTime
                if inRange
                    float barHigh = high[i]
                    float barLow = low[i]
                    float barRange = barHigh - barLow
                    float barVol = nz(volume[i])
                    bool isUpBar = close[i] >= open[i]

                    if barVol > 0 and barRange >= 0
                        if barRange < syminfo.mintick
                            int rowIdx = int(math.floor((close[i] - minPrice) / internalRowHeight))
                            rowIdx := math.max(0, math.min(rowIdx, vrvpInternalRows - 1))
                            if isUpBar
                                array.set(intUpVol, rowIdx, array.get(intUpVol, rowIdx) + barVol)
                            else
                                array.set(intDownVol, rowIdx, array.get(intDownVol, rowIdx) + barVol)
                            array.set(intTotalVol, rowIdx, array.get(intTotalVol, rowIdx) + barVol)
                        else
                            int rowStart = int(math.floor((barLow - minPrice) / internalRowHeight))
                            int rowEnd = int(math.floor((barHigh - minPrice) / internalRowHeight))
                            rowStart := math.max(0, math.min(rowStart, vrvpInternalRows - 1))
                            rowEnd := math.max(0, math.min(rowEnd, vrvpInternalRows - 1))

                            float totalWeight = 0.0
                            float volCenter = switch vrvpDistribution
                                "Typical Price Weighted" => (barHigh + barLow + close[i]) / 3
                                "Close Weighted" => close[i]
                                => (barHigh + barLow) / 2
                            float halfSpread = barRange / 2

                            for r = rowStart to rowEnd
                                float rowBottom = minPrice + (r * internalRowHeight)
                                float rowTop = rowBottom + internalRowHeight
                                float rowMid = (rowBottom + rowTop) / 2
                                float weight = 0.0

                                if vrvpDistribution == "Uniform"
                                    float overlapTop = math.min(barHigh, rowTop)
                                    float overlapBottom = math.max(barLow, rowBottom)
                                    float overlapRange = overlapTop - overlapBottom
                                    weight := overlapRange > 0 ? overlapRange / barRange : 0.0
                                else
                                    float overlapTop = math.min(barHigh, rowTop)
                                    float overlapBottom = math.max(barLow, rowBottom)
                                    if overlapTop > overlapBottom
                                        weight := math.max(vrvpWeightEps, f_triangleWeight(rowMid, volCenter, halfSpread))

                                totalWeight := totalWeight + weight

                            if totalWeight > 0
                                for r = rowStart to rowEnd
                                    float rowBottom = minPrice + (r * internalRowHeight)
                                    float rowTop = rowBottom + internalRowHeight
                                    float rowMid = (rowBottom + rowTop) / 2
                                    float weight = 0.0

                                    if vrvpDistribution == "Uniform"
                                        float overlapTop = math.min(barHigh, rowTop)
                                        float overlapBottom = math.max(barLow, rowBottom)
                                        float overlapRange = overlapTop - overlapBottom
                                        weight := overlapRange > 0 ? overlapRange / barRange : 0.0
                                    else
                                        float overlapTop = math.min(barHigh, rowTop)
                                        float overlapBottom = math.max(barLow, rowBottom)
                                        if overlapTop > overlapBottom
                                            weight := math.max(vrvpWeightEps, f_triangleWeight(rowMid, volCenter, halfSpread))

                                    if weight > 0
                                        float volContrib = barVol * (weight / totalWeight)
                                        if isUpBar
                                            array.set(intUpVol, r, array.get(intUpVol, r) + volContrib)
                                        else
                                            array.set(intDownVol, r, array.get(intDownVol, r) + volContrib)
                                        array.set(intTotalVol, r, array.get(intTotalVol, r) + volContrib)
                    int touchStart = int(math.floor((barLow - minPrice) / displayRowHeight))
                    int touchEnd = int(math.floor((barHigh - minPrice) / displayRowHeight))
                    touchStart := math.max(0, math.min(touchStart, vrvpDisplayRows - 1))
                    touchEnd := math.max(0, math.min(touchEnd, vrvpDisplayRows - 1))
                    for t = touchStart to touchEnd
                        if isUpBar
                            array.set(touchUp, t, array.get(touchUp, t) + 1)
                        else
                            array.set(touchDown, t, array.get(touchDown, t) + 1)

            var float[] volUp = array.new_float(vrvpDisplayRows, 0.0)
            var float[] volDown = array.new_float(vrvpDisplayRows, 0.0)
            var float[] volTotal = array.new_float(vrvpDisplayRows, 0.0)

            for i = 0 to vrvpDisplayRows - 1
                array.set(volUp, i, 0.0)
                array.set(volDown, i, 0.0)
                array.set(volTotal, i, 0.0)

            for i = 0 to vrvpInternalRows - 1
                float internalRowMid = minPrice + (i * internalRowHeight) + (internalRowHeight / 2)
                int displayIdx = int(math.floor((internalRowMid - minPrice) / displayRowHeight))
                displayIdx := math.max(0, math.min(displayIdx, vrvpDisplayRows - 1))
                array.set(volUp, displayIdx, array.get(volUp, displayIdx) + array.get(intUpVol, i))
                array.set(volDown, displayIdx, array.get(volDown, displayIdx) + array.get(intDownVol, i))
                array.set(volTotal, displayIdx, array.get(volTotal, displayIdx) + array.get(intTotalVol, i))

            for i = 0 to vrvpDisplayRows - 1
                if array.get(volTotal, i) == 0 and (array.get(touchUp, i) + array.get(touchDown, i)) > 0
                    if array.get(touchUp, i) >= array.get(touchDown, i)
                        array.set(volUp, i, vrvpWeightEps)
                    else
                        array.set(volDown, i, vrvpWeightEps)
                    array.set(volTotal, i, vrvpWeightEps)

            if vrvpShowDebug
                int minTouchIdx = na
                int maxTouchIdx = na
                for i = 0 to vrvpDisplayRows - 1
                    if (array.get(touchUp, i) + array.get(touchDown, i)) > 0
                        if na(minTouchIdx)
                            minTouchIdx := i
                        maxTouchIdx := i
                if not na(minTouchIdx)
                    float touchMinPrice = minPrice + (displayRowHeight * minTouchIdx)
                    float touchMaxPrice = minPrice + (displayRowHeight * (maxTouchIdx + 1))
                    array.push(vrvpLines, line.new(leftBarIndex, touchMaxPrice, rightBarIndex, touchMaxPrice,
                         xloc=xloc.bar_index, color=color.new(color.purple, 0), width=1, style=line.style_dotted))
                    array.push(vrvpLines, line.new(leftBarIndex, touchMinPrice, rightBarIndex, touchMinPrice,
                         xloc=xloc.bar_index, color=color.new(color.purple, 0), width=1, style=line.style_dotted))
                string debugText = "VRVP\nBars: " + str.tostring(visibleBars) + "\nRows: " + str.tostring(vrvpDisplayRows)
                debugText := debugText + "\nMin: " + str.tostring(minPrice, format.mintick)
                debugText := debugText + "\nMax: " + str.tostring(maxPrice, format.mintick)
                if not na(minTouchIdx)
                    debugText := debugText + "\nTouchMin: " + str.tostring(minPrice + (displayRowHeight * minTouchIdx), format.mintick)
                    debugText := debugText + "\nTouchMax: " + str.tostring(minPrice + (displayRowHeight * (maxTouchIdx + 1)), format.mintick)
                debugText := debugText + "\nLeftIdx: " + str.tostring(leftBarIndex)
                debugText := debugText + "\nRightIdx: " + str.tostring(rightBarIndex)
                vrvpSummaryLabel := label.new(x=rightBarIndex, y=maxPrice, text=debugText,
                     xloc=xloc.bar_index, style=label.style_label_left,
                     color=color.new(color.black, 70), textcolor=color.white,
                     size=size.small)

            if vrvpShowDebug and vrvpDebugTouchRows
                for i = 0 to vrvpDisplayRows - 1
                    if (array.get(touchUp, i) + array.get(touchDown, i)) > 0
                        float boxBottom = minPrice + (displayRowHeight * i)
                        float boxTop = minPrice + (displayRowHeight * (i + 1))
                        array.push(vrvpDebugBoxes, box.new(leftBarIndex, boxTop, rightBarIndex, boxBottom,
                             xloc=xloc.bar_index, border_width=1, border_color=color.new(color.purple, 0),
                             bgcolor=color.new(color.purple, 100)))

            float totalVpVolume = 0.0
            float maxVolInRow = 0.0
            int pocIdx = -1

            for i = 0 to vrvpDisplayRows - 1
                float v = array.get(volTotal, i)
                totalVpVolume := totalVpVolume + v
                if v > maxVolInRow
                    maxVolInRow := v
                    pocIdx := i

            int vaTopIdx = pocIdx
            int vaBottomIdx = pocIdx
            float currentVaVol = maxVolInRow
            float targetVaVol = totalVpVolume * (vrvpValueArea / 100.0)

            int loopSafety = 0
            while currentVaVol < targetVaVol and loopSafety < vrvpDisplayRows
                loopSafety := loopSafety + 1
                float upVol = (vaTopIdx < vrvpDisplayRows - 1) ? array.get(volTotal, vaTopIdx + 1) : 0.0
                float downVol = (vaBottomIdx > 0) ? array.get(volTotal, vaBottomIdx - 1) : 0.0
                if upVol == 0 and downVol == 0
                    break
                if upVol >= downVol
                    vaTopIdx := vaTopIdx + 1
                    currentVaVol := currentVaVol + upVol
                else
                    vaBottomIdx := vaBottomIdx - 1
                    currentVaVol := currentVaVol + downVol

            float pocPrice = minPrice + (displayRowHeight * pocIdx) + (displayRowHeight / 2)
            float vahPrice = minPrice + (displayRowHeight * vaTopIdx) + (displayRowHeight / 2)
            float valPrice = minPrice + (displayRowHeight * vaBottomIdx) + (displayRowHeight / 2)

            for i = 0 to vrvpDisplayRows - 1
                float totalV = array.get(volTotal, i)
                if totalV > 0 and maxVolInRow > 0
                    float boxBottom = minPrice + (displayRowHeight * i)
                    float boxTop = minPrice + (displayRowHeight * (i + 1))
                    float widthRatio = (totalV / maxVolInRow)
                    int barWidth = math.max(1, math.round(profileWidthBars * widthRatio))

                    int boxLeft = vrvpPlacement == "Right" ? rightBarIndex - barWidth : leftBarIndex
                    int boxRight = vrvpPlacement == "Right" ? rightBarIndex : leftBarIndex + barWidth

                    bool isVa = (i >= vaBottomIdx and i <= vaTopIdx)
                    bool isUpBar = array.get(volUp, i) >= array.get(volDown, i)

                    color bgColor = na
                    if isVa
                        bgColor := isUpBar ? vrvpUpVolumeVA : vrvpDownVolumeVA
                    else
                        bgColor := isUpBar ? vrvpUpVolumeOut : vrvpDownVolumeOut

                    color borderColor = vrvpBarBorder > 0 ? vrvpBarBorderColor : na
                    array.push(vrvpBoxes, box.new(boxLeft, boxTop, boxRight, boxBottom,
                         xloc=xloc.bar_index, border_width=vrvpBarBorder, border_color=borderColor, bgcolor=bgColor))

            if vrvpShowPocLine
                array.push(vrvpLines, line.new(leftBarIndex, pocPrice, rightBarIndex, pocPrice,
                     xloc=xloc.bar_index, color=vrvpPocCol, width=vrvpPocLineWidth))

            if vrvpShowPocLabel
                string priceText = "POC: " + str.tostring(pocPrice, format.mintick)
                vrvpPocLabel := label.new(x=(vrvpPlacement == "Right" ? leftBarIndex : rightBarIndex),
                     y=pocPrice, text=priceText, xloc=xloc.bar_index,
                     color=color.new(vrvpPocCol, 0), textcolor=color.black,
                     style=label.style_label_left, size=size.small)

            if vrvpShowVahLine and not na(vahPrice)
                line vahLine = line.new(leftBarIndex, vahPrice, rightBarIndex, vahPrice,
                     xloc=xloc.bar_index, color=vrvpVahCol, width=vrvpVahValLineWidth)
                array.push(vrvpLines, vahLine)

            if vrvpShowValLine and not na(valPrice)
                line valLine = line.new(leftBarIndex, valPrice, rightBarIndex, valPrice,
                     xloc=xloc.bar_index, color=vrvpValCol, width=vrvpVahValLineWidth)
                array.push(vrvpLines, valLine)

            if vrvpShowVaFill and not na(vahPrice) and not na(valPrice)
                line vahFillLine = line.new(leftBarIndex, vahPrice, rightBarIndex, vahPrice,
                     xloc=xloc.bar_index, color=color.new(color.white, 100), width=1)
                line valFillLine = line.new(leftBarIndex, valPrice, rightBarIndex, valPrice,
                     xloc=xloc.bar_index, color=color.new(color.white, 100), width=1)
                array.push(vrvpLines, vahFillLine)
                array.push(vrvpLines, valFillLine)
                array.push(vrvpFills, linefill.new(vahFillLine, valFillLine, vrvpVaFillCol))

            if vrvpShowSummary
                string summaryText = "POC: " + str.tostring(pocPrice, format.mintick)
                summaryText := summaryText + "\nVAH: " + str.tostring(vahPrice, format.mintick)
                summaryText := summaryText + "\nVAL: " + str.tostring(valPrice, format.mintick)

                int summaryX = vrvpPlacement == "Right" ? rightBarIndex : leftBarIndex
                float summaryY = vahPrice + ((vahPrice - valPrice) * 0.2)

                vrvpSummaryLabel := label.new(x=summaryX, y=summaryY, text=summaryText,
                     xloc=xloc.bar_index, style=label.style_label_left,
                     color=color.new(color.rgb(40, 92, 160), 20), textcolor=color.white,
                     size=size.normal)

            if vrvpMtfEnabled
                var float[] mtfTotals = array.new_float(vrvpInternalRows, 0.0)
                for i = 0 to vrvpInternalRows - 1
                    array.set(mtfTotals, i, 0.0)

                for i = 0 to leftOffset
                    bool inRange = time[i] >= leftTime and time[i] <= rightTime
                    if inRange
                        float barHigh = mtfHigh[i]
                        float barLow = mtfLow[i]
                        float barRange = barHigh - barLow
                        float barVol = nz(mtfVolume[i])

                        if barVol > 0 and barRange >= 0
                            if barRange < syminfo.mintick
                                int rowIdx = int(math.floor((mtfClose[i] - minPrice) / internalRowHeight))
                                rowIdx := math.max(0, math.min(rowIdx, vrvpInternalRows - 1))
                                array.set(mtfTotals, rowIdx, array.get(mtfTotals, rowIdx) + barVol)
                            else
                                int rowStart = int(math.floor((barLow - minPrice) / internalRowHeight))
                                int rowEnd = int(math.floor((barHigh - minPrice) / internalRowHeight))
                                rowStart := math.max(0, math.min(rowStart, vrvpInternalRows - 1))
                                rowEnd := math.max(0, math.min(rowEnd, vrvpInternalRows - 1))

                                float totalWeight = 0.0
                                float volCenter = switch vrvpDistribution
                                    "Typical Price Weighted" => (barHigh + barLow + mtfClose[i]) / 3
                                    "Close Weighted" => mtfClose[i]
                                    => (barHigh + barLow) / 2
                                float halfSpread = barRange / 2

                                for r = rowStart to rowEnd
                                    float rowBottom = minPrice + (r * internalRowHeight)
                                    float rowTop = rowBottom + internalRowHeight
                                    float rowMid = (rowBottom + rowTop) / 2
                                    float weight = 0.0

                                    if vrvpDistribution == "Uniform"
                                        float overlapTop = math.min(barHigh, rowTop)
                                        float overlapBottom = math.max(barLow, rowBottom)
                                        float overlapRange = overlapTop - overlapBottom
                                        weight := overlapRange > 0 ? overlapRange / barRange : 0.0
                                    else
                                        float overlapTop = math.min(barHigh, rowTop)
                                        float overlapBottom = math.max(barLow, rowBottom)
                                        if overlapTop > overlapBottom
                                            weight := math.max(vrvpWeightEps, f_triangleWeight(rowMid, volCenter, halfSpread))

                                    totalWeight := totalWeight + weight

                                if totalWeight > 0
                                    for r = rowStart to rowEnd
                                        float rowBottom = minPrice + (r * internalRowHeight)
                                        float rowTop = rowBottom + internalRowHeight
                                        float rowMid = (rowBottom + rowTop) / 2
                                        float weight = 0.0

                                        if vrvpDistribution == "Uniform"
                                            float overlapTop = math.min(barHigh, rowTop)
                                            float overlapBottom = math.max(barLow, rowBottom)
                                            float overlapRange = overlapTop - overlapBottom
                                            weight := overlapRange > 0 ? overlapRange / barRange : 0.0
                                        else
                                            float overlapTop = math.min(barHigh, rowTop)
                                            float overlapBottom = math.max(barLow, rowBottom)
                                            if overlapTop > overlapBottom
                                                weight := math.max(vrvpWeightEps, f_triangleWeight(rowMid, volCenter, halfSpread))

                                        if weight > 0
                                            float volContrib = barVol * (weight / totalWeight)
                                            array.set(mtfTotals, r, array.get(mtfTotals, r) + volContrib)

                float mtfMaxVol = 0.0
                int mtfPocIdx = -1
                for i = 0 to vrvpInternalRows - 1
                    float v = array.get(mtfTotals, i)
                    if v > mtfMaxVol
                        mtfMaxVol := v
                        mtfPocIdx := i

                if mtfPocIdx >= 0
                    float mtfPocPrice = minPrice + (internalRowHeight * mtfPocIdx) + (internalRowHeight / 2)
                    array.push(vrvpLines, line.new(leftBarIndex, mtfPocPrice, rightBarIndex, mtfPocPrice,
                         xloc=xloc.bar_index, color=vrvpPocCol, width=math.max(1, vrvpPocLineWidth - 1), style=line.style_dashed))

    // Draw message label
    string msg = ""

    // Determine bias
    if close > vwapVal
        msg := " BULLISH\nAbove VWAP"

        // Add primary target
        if not na(hvn)
            msg := msg + "\n\n Target: " + str.tostring(hvn, format.mintick) + " (HVN)"
        else if not na(poc)
            msg := msg + "\n\n Target: " + str.tostring(poc, format.mintick) + " (POC)"

        // Add W3 status if available
        if not na(lastW3Status) and not na(lastW3Target)
            msg := msg + "\n\n " + lastW3Status
            if lastW3Status != "W3 Confirmed"
                msg := msg + "\nProjected: " + str.tostring(lastW3Target, format.mintick)

        // Add invalidation
        msg := msg + "\n\n Invalidate: Below VWAP"

    else if close < vwapVal
        msg := " BEARISH\nBelow VWAP"

        // Add primary target
        if not na(lvn)
            msg := msg + "\n\n Target: " + str.tostring(lvn, format.mintick) + " (LVN)"
        else if not na(poc)
            msg := msg + "\n\n Target: " + str.tostring(poc, format.mintick) + " (POC)"

        // Add W3 status if available
        if not na(lastW3Status) and not na(lastW3Target)
            msg := msg + "\n\n " + lastW3Status
            if lastW3Status != "W3 Confirmed"
                msg := msg + "\nProjected: " + str.tostring(lastW3Target, format.mintick)

        // Add invalidation
        msg := msg + "\n\n Invalidate: Above VWAP"

    else
        msg := " NEUTRAL\nAt VWAP\n\nWait for confirmation"

    if showMessage
        // Position message using recent high/low for more accurate placement
        // Find the highest/lowest points in the visible range where label will appear
        float maxHigh = high
        float minLow = low
        for i = 0 to math.min(200, bar_index)
            maxHigh := math.max(maxHigh, high[i])
            minLow := math.min(minLow, low[i])

        float priceRange = maxHigh - minLow
        int msgX = bar_index + msgXOffset - 25

        // Check both positions (above and below) with larger offsets
        float labelAbove = maxHigh + (priceRange * 0.10)  // 10% above highest point
        float labelBelow = minLow - (priceRange * 0.10)   // 10% below lowest point

        // Check if placing above would overlap with nearby candles
        bool overlapAbove = false
        for i = 0 to math.min(100, bar_index)
            if high[i] >= labelAbove
                overlapAbove := true
                break

        // Check if placing below would overlap with nearby candles
        bool overlapBelow = false
        for i = 0 to math.min(100, bar_index)
            if low[i] <= labelBelow
                overlapBelow := true
                break

        // Choose position with no overlap, prefer above if both are clear
        float msgY = na
        string labelStyle = ""

        if not overlapAbove
            // Place above - use lower_right style (label extends up)
            msgY := labelAbove
            labelStyle := label.style_label_lower_right
        else if not overlapBelow
            // Place below - use upper_right style (label extends down)
            msgY := labelBelow
            labelStyle := label.style_label_upper_right
        else
            // Both have overlap, place further above
            msgY := maxHigh + (priceRange * 0.20)
            labelStyle := label.style_label_lower_right

        msgLabel := label.new(msgX, msgY, msg,
             xloc=xloc.bar_index, yloc=yloc.price,
             style=labelStyle,
             textcolor=labelTextCol, color=labelBgCol,
             size=lblSize, textalign=text.align_left)

// ============================================================================
// ALERTS
// ============================================================================
alertcondition(close > vwapVal, "Above VWAP", "Close is above VWAP.")
alertcondition(close < vwapVal, "Below VWAP", "Close is below VWAP.")
